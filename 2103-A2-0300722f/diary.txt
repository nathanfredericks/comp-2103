# Code Diary
## Task 1
- I am researching how to read input from stdin.
- In the textbook, I found the `fgets` function which can read from stdin. I am going to try using that.
- I did some more research and decided to try reading each character instead. I'm going to use `getc` and follow the example in the slides. I'm going to modify the example from `fgetc` to `getc`.
- I started writing the code and forgot to how properly define the main function... researching.
- On the right track with `void main(void)`
- Following the example, in your slides. My code will work by doing the following steps:
	- Initialize a variable for c (the character).
	- Use getc and a while loop to loop over every character in stdin.
		- Print the character to the terminal.
	- Return exit success.
- Back to coding... following the above steps.
- Vim is showing an error. main must return int. I changed the return type to int. This makes sense because I'm returning EXIT_SUCCESS or EXIT_FAILURE which are numbers.
- I got an error with my `getc` function. I need to pass something in. Researching...
- I'm going to try passing in `stdin`.
- There are no errors, now I am going to research how to print that character.
- I'm going to use `printf` passing in the character.
- The program works, however when I don't pass in a redirect, the code ends up hanging.
- I'm going to do some research on how to fix this.
- After reading lots of StackOverflow answers, I decided on reading in 1 character and checking if it's `EOF`. If it is, return EXIT_FAILURE and stop.
- I'm going to use `feof` to double-check that it is indeed an `EOF`. This is similar to one answer from StackOverflow.
- Testing my code, it does not work. Now it is cutting off the first letter.
- After doing some reading, I am changing my print method to use `putc` to stdout.
- Now I'm going to do some debugging. I'm going to check `getc` at the start of the program to find out what is inside when not passing anything in stdin.
- The code appears to hang because it is waiting for input from getc.
- I am going to try checking if getc is `\n` or `EOF`
- This still does not work, I'm going to temporarily ignore the error and move on to the next task.
- Back to work! I did some searching online and am going to use `feof`. According to the man page, the functions check for an EOF.
- No luck. I'm going to try taking a different approach by checking how many arguments the program is being run with.
- This also doesn't work. Since `< test.txt` is not treated as an argument.
- I'm going to try getting the first character and checking if it's EOF.
- The code is still not functioning properly.
- I saw on StackOverflow that there is a `isatty()` function which checks if the file descriptor (stdin) is referring to a terminal.
- I tried using the function and my code works as expected.
- I updated my file for task 2 to use the same function.

## Task 2
- I'm going to start by checking if the character is uppercase using `isupper(c)`.
- Then I'm going to convert the char to the opposite and output it to stdout.
- I'm getting error `call to undeclared library function 'isupper' with t...nction declarations`.
- I did some research and am going to import `ctype.h`.
- Problem fixed!
- To convert, I'm going to use `toupper` and `tolower`. These should return an int which I will output to stdout.
- The code works as expected.
- I noticed that Task 1 and Task 2 have many similarities. I'm going to merge them and use an IFDEF to conditionally compile one or the other.
- I'm getting an error.
```
test.c:12:2: error: invalid preprocessing directive
#IFDEF SWITCHED
```
- I did some searching and found out that ifdef and endif have to be lowercase.
- Testing and the code works properly. Moving onto task 3.

## Task 3
- I'm going to start by creating a temp file, then I'm going to open the temp file and write each character to it. Afterwards, I'll use `fseek` to get the last character of the file and print it to the screen. This will be in a loop and continue from the end of the file to the beginning.
- `fseek` should start with the offset being 0 and whence being SEEK_END the position of the cursor at the end of the file.
- Starting by creating a temp file, I'll follow the instructions in the slides.
- I created a temp file, and now I'm using some ifdef statements so that `putc(stdout)` only runs if task 1/2 is selected. Otherwise `putc(tempfile)` is run.
- Testing my code, I am getting an infinite loop of blank characters being printed on the screen.
- I did some debugging and found out that I wasn't even writing to the temp file. I changed `putc` to `fputc`.
- After testing my code, the infinite loop still occurs. It does not appear that `fseek` is working properly to reverse my cursor position.
- After lots of searching on Google and StackOverflow, I found a new solution.
- I'm going to set the cursor to the end of the file, then use the `ftell` function to get my current position in the file. I'll have a counter that will count up every time I put a character. In a loop, I'll continue reading the file backwards until I've read the total number of characters in the file.
- After writing the code and testing, everything appears to work as expected.
